use chess::board::Board;
use chess::color::Color;
use chess::piece::Piece;

use crate::utils;

const PAWNS: [f32; 64] = [
	0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
	0.05, 0.1, 0.1, -0.2, -0.2, 0.1, 0.1, 0.05,
	0.05, -0.05, -0.1, 0.0, 0.0, -0.1, -0.05, 0.05,
	0.0, 0.0, 0.0, 0.2, 0.2, 0.0, 0.0, 0.0,
	0.05, 0.05, 0.1, 0.25, 0.25, 0.1, 0.05, 0.05,
	0.1, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0.1,
	0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5,
	0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
];

const ROOKS: [f32; 64] = [
	0.0, 0.0, 0.0, 0.05, 0.05, 0.0, 0.0, 0.0,
	-0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.05,
	-0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.05,
	-0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.05,
	-0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.05,
	-0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.05,
	0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05,
	0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
];

const KNIGHTS: [f32; 64] = [
	-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5,
	-0.4, -0.2, 0.0, 0.05, 0.05, 0.0, -0.2, -0.4,
	-0.3, 0.05, 0.1, 0.15, 0.15, 0.1, 0.05, -0.3,
	-0.3, 0.0, 0.15, 0.2, 0.2, 0.15, 0.0, -0.3,
	-0.3, 0.05, 0.15, 0.2, 0.2, 0.15, 0.05, -0.3,
	-0.3, 0.0, 0.1, 0.15, 0.15, 0.1, 0.0, -0.3,
	-0.4, -0.2, 0.0, 0.0, 0.0, 0.0, -0.2, -0.4,
	-0.5, -0.4, -0.3, -0.3, -0.3, -0.3, -0.4, -0.5,
];

const BISHOPS: [f32; 64] = [
	-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2,
	-0.1, 0.05, 0.0, 0.0, 0.0, 0.0, 0.05, -0.1,
	-0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, -0.1,
	-0.1, 0.0, 0.1, 0.1, 0.1, 0.1, 0.0, -0.1,
	-0.1, 0.05, 0.05, 0.1, 0.1, 0.05, 0.05, -0.1,
	-0.1, 0.0, 0.05, 0.1, 0.1, 0.05, 0.0, -0.1,
	-0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.1,
	-0.2, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.2,
];

const QUEENS: [f32; 64] = [
	-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2,
	-0.1, 0.0, 0.05, 0.0, 0.0, 0.0, 0.0, -0.1,
	-0.1, 0.05, 0.05, 0.05, 0.05, 0.05, 0.0, -0.1,
	0.0, 0.0, 0.05, 0.05, 0.05, 0.05, 0.0, -0.05,
	-0.05, 0.0, 0.05, 0.05, 0.05, 0.05, 0.0, -0.05,
	-0.1, 0.0, 0.05, 0.05, 0.05, 0.05, 0.0, -0.1,
	-0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.1,
	-0.2, -0.1, -0.1, -0.05, -0.05, -0.1, -0.1, -0.2,
];

const KINGS_EARLY: [f32; 64] = [
	0.2, 0.3, 0.1, 0.0, 0.0, 0.1, 0.3, 0.2,
	0.2, 0.2, 0.0, 0.0, 0.0, 0.0, 0.2, 0.2,
	-0.1, -0.2, -0.2, -0.2, -0.2, -0.2, -0.2, -0.1,
	-0.2, -0.3, -0.3, -0.4, -0.4, -0.3, -0.3, -0.2,
	-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3,
	-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3,
	-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3,
	-0.3, -0.4, -0.4, -0.5, -0.5, -0.4, -0.4, -0.3,
];


const KINGS_ENDGAME: [f32; 64] = [
	-0.5, -0.3, -0.3, -0.3, -0.3, -0.3, -0.3, -0.5,
	-0.3, -0.3, 0.0, 0.0, 0.0, 0.0, -0.3, -0.3,
	-0.3, -0.1, 0.2, 0.3, 0.3, 0.2, -0.1, -0.3,
	-0.3, -0.1, 0.3, 0.4, 0.4, 0.3, -0.1, -0.3,
	-0.3, -0.1, 0.3, 0.4, 0.4, 0.3, -0.1, -0.3,
	-0.3, -0.1, 0.2, 0.3, 0.3, 0.2, -0.1, -0.3,
	-0.3, -0.2, -0.1, 0.0, 0.0, -0.1, -0.2, -0.3,
	-0.5, -0.4, -0.3, -0.2, -0.2, -0.3, -0.4, -0.5,
];

const TABLES: [[f32; 64]; 5] = [
    PAWNS, ROOKS, KNIGHTS,
    BISHOPS, QUEENS
];

/// Returns the heuristic value of a piece, in pawns.
#[inline]
pub(crate) const fn value_of(piece: Piece) -> f32 {
    match piece {
        Piece::Pawn => 1.0,
        Piece::Rook => 5.0,
        Piece::Knight => 3.2,
        Piece::Bishop => 3.3,
        Piece::Queen => 9.0,
        Piece::King => 200.0,
    }
}

/// The evaluation function.
pub(crate) fn eval(board: &Board) -> f32 {
    let mut score = 0.0;

    for &piece in &Piece::PIECES[..5] {
        for sq in board.get_bitboard(Color::White, piece).iter_squares() {
            score += value_of(piece) + TABLES[usize::from(piece)][usize::from(sq)];
        }
        
        for sq in board.get_bitboard(Color::Black, piece).iter_squares() {
            score -= value_of(piece) + TABLES[usize::from(piece)][63 - usize::from(sq)];
        }  
    }

	let white_king_sq = utils::king_sq_color(board, Color::White);
	let black_king_sq = utils::king_sq_color(board, Color::Black);

    if utils::is_endgame(board) {
        score += KINGS_ENDGAME[usize::from(white_king_sq)];
        score -= KINGS_ENDGAME[63 - usize::from(black_king_sq)];
    } else {
        score += KINGS_EARLY[usize::from(white_king_sq)];
        score -= KINGS_EARLY[63 - usize::from(black_king_sq)];
    }

	if board.get_side_to_move() == Color::Black {
		score = -score;
	}

    score
}